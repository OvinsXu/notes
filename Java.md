## 面向对象
-----
### 1.类和对象

#### 类：事物的描述，某种概念
  - 定义语法：

        [修饰符] class 类名
         {
        	 构造器...
        	 成员变量...
        	 成员方法...
         }

  可以包括成员变量，方法，构造器，初始化块，内部类
#### 对象：该类事物的实例，在Java中通过new来创建。
  - 定义语法：

        类名 对象名 = new 类名(参数);
 

### 2.方法详解

#### 所属性
- 方法必须属于类或对象。必须在类中定义。
- 如果使用`static`修饰，则这个方法属于它所在的类，否则属于这个类的实例。

#### 形参可变
 - 在最后形参后加 "..."，则表明该形参可以接收多个参数值，多个参数值被当作数组传入。

#### 方法重载
 - 同一个类中定义多个同名方法，但是形参不同的情况称为方法重载。
 - 对于返回值类型，修饰符等，与方法重载无关。

### 3.成员变量和局部变量

#### 成员变量

   1. 类变量（在类定义中使用了`static`修饰符）
   2.  实例变量（在类定义中没有使用`static`修饰符隐藏和封装）

#### 局部变量

   1. 形参（方法签名中定义的变量）
   2. 方法局部变量（在方法中定义的变量）
   3. 代码块局部变量（在代码块中定义的变量）

### 4.隐藏和封装

 - 访问控制符

     - `private`        同类
     - `default`        同类 同包
     - `protected`    同类 同包 子类中
     - `public`          同类 同包 子类中 全局范围内

 - 包管理
      -  `package `         指定一个类放在指定的包里，在Java源程序第一个非注释行指定
      -  `import  `          导入指定包层次下的某个或所有类
      -  `import static`   导入指定类的一个或所有静态成员变量

### 5.构造器

 - 创建对象时执行初始化。
 - 同一类中拥有多个构造器，但是形参不一样，则称之为构造器重载。
 - 系统根据形参选择构造器进行初始化。

### 6.继承

 - 特点
     - 子类无法获取父类的构造器。
 - 语法

        修饰符 class 子类名 extends 父类名
        {
            //code
        }

 - 重写
     - 子类含有与父类同名的方法时，子类定义的方法会覆盖父类的方法，称之为方法重写。

 - super限定
     - 当子类发生了方法重写后，可以通过super来访问父类中被重写的方法。
 - 调用父类构造器
     - 在子类中，通过`super(形参)`；的形式调用父类构造器
     - 子类会默认调用一次父类的构造器。父类构造器总会在子类构造器执行之前执行。

### 7.多态
 - 类名1 对象  =new 类名2();
     - 类名1是编译时类型，类名2是运行时类型。
     - 对象只能执行类名1里的方法。               
     - 成员方法具有多态性，而成员变量没有。

 - 类型转换
     - 语法：      `(type)variable`
     - 基本类型之间，只有数值类型可以相互转换，包括整数形，字符型，浮点型
     - 引用类型之间，只能在具有继承关系的两个类型之间转换
 - instanceof
     - `操作数1 instanceof 操作数2`
     - 用于判断前一个对象是否时后面的类，或者其子类，其实例，是/否   返truefalse
### 8.继承和组合
 - 尽量不要在父类构造器中调用将被子类重写的方法。
 - 通过继承来进行类的复用，往往可以通过组合来实现，及 在新类中定义一个久类的对象，如果用`private`修饰，则可以保证父类的封装性。
### 9.初始化块
 - 语法
    ``` 
    [修饰符] {
         //code
    }
    ```
     - 修饰符只能是static，用static修饰的初始化块称之为静态初始化块，也称类初始化块。它在类初始化时执行，普通初始化块是在实例初始化时执行，所以类初始化块更先被执行。

### 10.包装类
 - 为了解决基本类型数据不具备对象的特性，Java提供了相应的包装类。
     - 1.`byte，short，int，long，char，float，double，boolean`  ---->Byte ,Short, Integer, Long, Charecter, Float, Double, Boolean

 - 字符串类型值 ---> 基本类型值

     - 1. `parseXxx(String s) `            int i = Integer.parseInt("123");
     - 2. `Xxx(String s)构造器 `           int i = new Integer("123");

 - 基本类型值 ----> 字符类型值

     - 1. `valueOf()   `                        String s = valueOf(3.14);
     - 2. `基本类型值 + " " `               String s = 3.14 + " "

 - 数值比较
    - 静态的 `compare(xxx val1,xxx val2) `                     true>false
 -  ...
### 11.处理对象

 - 打印对象和toString()

    - 1. 打印对象其实是输出对象的toString()方法的返回值，toString()是Object对象实例方法，Java中所有对象皆为Object对象的子类，因此都具有toString()方法，默认出“类名+@+哈希值”，可以通过方法重写实现自身功能。
 -  ==和equal方法
    - 基本类型变量的值相等则返回true，否则为false
    - 引用类型变量指向同一对象时，返回true，否则为false。

### 12.类成员
 -  用`static`修饰的成员变量，方法，初始化块，内部类，称之为类成员，类成员属于类，而不属于实例。类成员无法访问实例成员。
 -  单例类：一个类只能创建一个实例，则这个类被称之为单例类。
```
    /*
    1.将构造器隐藏，使之无法new
    2.定义一个类方法，由类进行new，故需public
    *
    //懒汉式
    class 单例类名
    {
              private static 单例类名 val；     		//val用来存放曾经创建   例
          private 单例类名(){};                  //将构造器隐藏
          public static 单例类名 func（）{		//定义类方法
              if(val == null)
               {
                       val = new 单例类名();
               }
               return val;
           }
    }
```
### 13.final修饰符
 - 其修饰的类，方法，变量不可改变。
     - 类：final修饰的类不可以有子类。
     - 方法：final修饰的方法不可以被重写。但是可以重载。
     - 变量：只能赋值一次。
     - 不可变类...
     - 缓存实例的不可变类...

### 14.抽象类
 - 定义抽象类只需要在普通类上增加abstract修饰符即可
 - 抽象类只能被继承，抽象方法必须在子类中被重写
 - `final`，`private`和`abstract`永远不可能同时修饰某个方法

### 15.接口
 - 定义方法
```
    [修饰符] interface 接口名 extends 父接口1,父接口2...
    {
        //code...
        //定义而不实现.
    }
``` 
 - 接口支持多继承
 - 使用接口
```
    [修饰符] class 类名 extends 父类 implements 接口1,接口2...
    {
       //code...
    }
```        

 
 - 面向接口编程
     -  简单工厂模式
          1. ​    Computer类 -> Printer方法    如果Printer改变，则需在Computer类中改
          2. ​    Computer类 -> Output对象 -> Printer方法
          3. 。。。

     - 命令模式
          1. ​    接口 定义 处理方法(参数)
          2. ​    类->方法(参数，处理方法)
          3. ​    主->创建实例时指定处理方法
          4. ​    定义 处理方法1，处理方法2

### 16.内部类
 - 定义在其他类内部的类称之为内部类，包含内部类的类称之为外部类或宿主类。
 - 不允许同一个包中的其他类访问该类。
 - 内部类成员可以直接访问外部类的私有数据。
 - 匿名内部类可以用来创建仅需使用一次的的类。
 - 非静态内部类内不许定义静态成员。
 - 。。。

### 17.Lambda表达式

 - 支持将代码块作为方法参
 - ES6里的箭头函数就是Lambda表达式

### 18.枚举类
- 格式：
```
    [修饰符] enum 类名{
            实例1，实例2；
    }
```

 - 使用时可通过 `类名.实例1` 的形式。
 - `类名.values() `代表了所有的实例。

### 19.对象和垃圾回收
 - 可达状态：对象有引用
 - 可恢复状态：对象没有引用，系统准备回收其空间前，执行`finalize`方法
 - 不可达状态：调用了finalize方法后，没有将对象恢复成可达状态
 - 强制回收：`System.gc( ) `和 `Runtime.getRuntime.gc( )`

### 20.修饰符的适用范围

### 21.使用jar文件
 - jar cf 包名 路径
 - cvf 显示过程~
 - cvfM 不生成清单文件
 - jar xf 包名 （解压）
 - xfe 变成可执行的















