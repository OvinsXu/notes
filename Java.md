## 面向对象

1. 1. ### 类和对象

   2. - 类：事物的描述，某种概念
      - 定义语法：

      -     ```java
        [修饰符] class 类名
         {
        	 构造器...
        	 成员变量...
        	 成员方法...
         }
            ```

      - 

      - 可以包括成员变量，方法，构造器，初始化块，内部类

      - 对象：该类事物的实例，在Java中通过new来创建。
      - 定义语法：

      -     ```java
        类名 对象名 = new 类名(参数);
            ```

      - 

   3. ### 方法详解

   4. 1. 所属性

      2. - 方法必须属于类或对象。必须在类中定义。
         - 如果使用`static`修饰，则这个方法属于它所在的类，否则属于这个类的实例。

      3. 形参可变

      4. - 在最后形参后加 "..."，则表明该形参可以接收多个参数值，多个参数值被当作数组传入。

      5. 方法重载

      6. - 同一个类中定义多个同名方法，但是形参不同的情况称为方法重载。
         - 对于返回值类型，修饰符等，与方法重载无关。

   5. ### 成员变量和局部变量

   6. 1. 成员变量

      2. 1. 类变量（在类定义中使用了`static`修饰符）
         2. 实例变量（在类定义中没有使用`static`修饰符隐藏和封装）

      3. 局部变量

      4. 1. 形参（方法签名中定义的变量）
         2. 方法局部变量（在方法中定义的变量）
         3. 代码块局部变量（在代码块中定义的变量）

   7. ### 隐藏和封装

   8. 1. 访问控制符

      2. - `private`        同类
         - `default`        同类 同包
         - `protected`    同类 同包 子类中
         - `public`          同类 同包 子类中 全局范围内

      3. 包管理

      4. 1. `package `         指定一个类放在指定的包里，在Java源程序第一个非注释行指定
         2. `import  `          导入指定包层次下的某个或所有类
         3. `import static`   导入指定类的一个或所有静态成员变量

   9. ### 构造器

   10. - 创建对象时执行初始化。
       - 同一类中拥有多个构造器，但是形参不一样，则称之为构造器重载。系统根据形参选择构造器进行初始化。

   11. ### 继承

   12. 1. 特点

       2. - 子类无法获取父类的构造器。

          - 语法

            ```java
            修饰符 class 子类名 extends 父类名
            {
            	      //code
            }
            ```

            

       3. ​       

       4. 重写

       5. - 子类含有与父类同名的方法时，子类定义的方法会覆盖父类的方法，称之为方法重写。

       6. super限定

       7. - 当子类发生了方法重写后，可以通过super来访问父类中被重写的方法。

       8. 调用父类构造器

       9. - 在子类中，通过`super(形参)`；的形式调用父类构造器
          - 子类会默认调用一次父类的构造器。父类构造器总会在子类构造器执行之前执行。

   13. ### 多态

   14. - `类名1 对象  =new 类名2();`

       - - 类名1是编译时类型，类名2是运行时类型。
         - 对象只能执行类名1里的方法。

       - 成员方法具有多态性，而成员变量没有。

       - 类型转换

       - 1. 语法：      `(type)variable`
         2. 基本类型之间，只有数值类型可以相互转换，包括整数形，字符型，浮点型
         3. 引用类型之间，只能在具有继承关系的两个类型之间转换

       - instanceof

       - - `操作数1 instanceof 操作数2`
         - 用于判断前一个对象是否时后面的类，或者其子类，其实例，是/否   返回  true/false

   15. ### 继承和组合

   16. 1. 尽量不要在父类构造器中调用将被子类重写的方法。
       2. 通过继承来进行类的复用，往往可以通过组合来实现，及 在新类中定义一个久类的对象，如果用`private`修饰，则可以保证久类的封装性。

   17. ### 初始化块

   18. - 语法

   19.            ```java
       [修饰符] {
            //code
       }
                  ```

   20. 

   21. - 修饰符只能是static，用static修饰的初始化块称之为静态初始化块，也称类初始化块。它在类初始化时执行，普通初始化块是在实例初始化时执行，所以类初始化块更先被执行。

   22. ### 包装类

   23. 1. 为了解决基本类型数据不具备对象的特性，Java提供了相应的包装类。

       2. `byte，short，int，long，char，float，double，boolean`  ---->Byte ,Short, Integer, Long, Charecter, Float, Double, Boolean

       3. 字符串类型值 ---> 基本类型值

       4. 1. `parseXxx(String s) `            int i = Integer.parseInt("123");
          2. `Xxx(String s)构造器 `           int i = new Integer("123");

       5. 基本类型值 ----> 字符类型值

       6. 1. `valueOf()   `                        String s = valueOf(3.14);
          2. `基本类型值 + " " `               String s = 3.14 + " "

       7. 数值比较

       8. 1. 静态的 `compare(xxx val1,xxx val2) `                     true>false

       9. ...

   24. ### 处理对象

   25. 1. 打印对象和toString()

       2. - 打印对象其实是输出对象的toString()方法的返回值，toString()是Object对象的实例方法，Java中所有对象皆为Object对象的子类，因此都具有toString()方法，默认输出“类名+@+哈希值”，可以通过方法重写实现自身功能。

       3. ==和equal方法

       4. 1. 基本类型变量的值相等则返回true，否则为false
          2. 引用类型变量指向同一对象时，返回true，否则为false。

   26. ### 类成员

   27. 1. 用`static`修饰的成员变量，方法，初始化块，内部类，称之为类成员，类成员属于类，而不属于实例。类成员无法访问实例成员。
       2. 单例类：一个类只能创建一个实例，则这个类被称之为单例类。
       3.    ```java
          /*
          1.将构造器隐藏，使之无法new
          2.定义一个类方法，由类进行new，故需public
          */ 
          
          //懒汉式
          class 单例类名
          {
                private static 单例类名 val；     		//val用来存放曾经创建的实例
                private 单例类名(){};                  //将构造器隐藏
                public static 单例类名 func（）{		//定义类方法
                    if(val == null)
                     {
                         val = new 单例类名();
                     }
                     return val;
                 }
          }
             ```

       4. 

   28. ### final修饰符

   29. 1. 其修饰的类，方法，变量不可改变。
       2. 类：final修饰的类不可以有子类。
       3. 方法：final修饰的方法不可以被重写。但是可以重载。
       4. 变量：只能赋值一次。
       5. 不可变类
       6. 缓存实例的不可变类

   30. ### 抽象类

   31. 1. 定义抽象类只需要在普通类上增加abstract修饰符即可。
       2. 抽象类只能被继承，抽象方法必须在子类中被重写。
       3. `final`，`private`和`abstract`永远不可能同时修饰某个方法

   32. ### 接口

   33. 1. 定义方法

       2.     ```java
          [修饰符] interface 接口名 extends 父接口1,父接口2...
          {
                //code...
                //定义而不实现.
          }
              ```

       3. 

       4. 接口支持多继承

       5. 使用接口

       6.     ```java
          [修饰符] class 类名 extends 父类 implements 接口1,接口2...
          {
             //code...
          }
              ```

       7. 

       8. 面向接口编程

       9. 1. 简单工厂模式
          2. ​    Computer类 -> Printer方法    如果Printer改变，则需在Computer类中改

          3. ​    Computer类 -> Output对象 -> Printer方法

          4. 。。。

          5. 命令模式
          6. ​    接口 定义 处理方法(参数)

          7. ​    类->方法(参数，处理方法)

          8. ​    主->创建实例时指定处理方法

          9. ​    定义 处理方法1，处理方法2

   34. ### 内部类

   35. 1. 定义在其他类内部的类称之为内部类，包含内部类的类称之为外部类或宿主类。
       2. 不允许同一个包中的其他类访问该类。
       3. 内部类成员可以直接访问外部类的私有数据。
       4. 匿名内部类可以用来创建仅需使用一次的的类。
       5. 非静态内部类内不许定义静态成员。
       6. 。。。

   36. ### Lambda表达式

   37. 1. 支持将代码块作为方法参数
       2. ES6里的箭头函数就是Lambda表达式

   38. ### 枚举类

   39. ​       格式：

   40.               ```java
        [修饰符] enum 类名{
                实例1，实例2；
        }
                     ```

   41. 

   42. 1. 使用时可通过 类名.实例1 的形式。
       2. `类名.values() `代表了所有的实例。

   43. ### 对象和垃圾回收

   44. 1. 可达状态：对象有引用
       2. 可恢复状态：对象没有引用，系统准备回收其空间前，执行`finalize`方法
       3. 不可达状态：调用了finalize方法后，没有将对象恢复成可达状态
       4. 强制回收：`System.gc( ) `和 `Runtime.getRuntime.gc( )`

   45. ### 修饰符的适用范围

   46. ### 使用jar文件

   47. 1. jar cf 包名 路径
       2. cvf 显示过程
       3. cvfM 不生成清单文件
       4. jar xf 包名 （解压）
       5. xfe 变成可执行的















